<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>polys silly rngame</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: arial, sans-serif;
            background: linear-gradient(135deg, #ffc0cb 0%, #ffffff 100%);
            min-height: 100vh;
            transition: background 0.5s, color 0.5s;
        }
        
        body.dark-mode {
            background: linear-gradient(135deg, #2d2d2d 0%, #000000 100%);
            color: #fff;
        }
        
        body.dark-mode .container {
            background: rgba(30, 30, 30, 0.9);
            color: #fff;
        }
        
        body.dark-mode .stat-box {
            background: #333;
        }
        
        body.dark-mode .stat-label {
            color: #ccc;
        }
        
        body.dark-mode .cooldown-settings {
            background: #333;
            color: #fff;
        }
        
        body.dark-mode .cooldown-settings label {
            color: #ccc;
        }
        
        body.dark-mode .roll-display {
            background: #222;
            border-color: #ff69b4;
        }
        
        body.dark-mode .rng-box {
            background: transparent;
        }
        
        body.dark-mode .upgrade-box,
        body.dark-mode .inventory,
        body.dark-mode .enchant-inventory,
        body.dark-mode .index-category {
            background: #333;
            color: #fff;
        }
        
        body.dark-mode .inventory-item,
        body.dark-mode .enchant-item {
            background: #444;
        }
        
        body.dark-mode .upgrade-title {
            color: #ff69b4;
        }
        
        body.dark-mode .upgrade-info {
            color: #ccc;
        }
        
        body.dark-mode button {
            background: #555;
        }
        
        body.dark-mode button:hover {
            background: #777;
        }
        
        body.dark-mode input {
            background: #444;
            color: #fff;
            border-color: #666;
        }
        
        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            z-index: 1000;
            font-size: 14px;
        }
        
        body.dark-mode .dark-mode-toggle {
            background: #666;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #ff69b4;
            margin-bottom: 30px;
            text-transform: lowercase;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat-box {
            background: #f0f0f0;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
            text-transform: lowercase;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff69b4;
        }
        .rollers-container {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .roll-display {
            background: #ffffff;
            border: 3px solid #ff69b4;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            width: 180px;
            height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }
        .variant-box {
            background: #ff69b4;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 5px;
            text-transform: lowercase;
        }
        .rng-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
        }
        .roll-result {
            font-size: 28px;
            margin-bottom: 5px;
        }
        .roll-name {
            font-size: 16px;
            color: #ff69b4;
            text-transform: lowercase;
        }
        .enchants-box {
            background: #f0f0f0;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            margin-top: 5px;
            min-height: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 3px;
            position: relative;
        }
        .enchant-tag {
            background: #9370db;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            text-transform: lowercase;
        }
        .star-indicator {
            position: absolute;
            top: -8px;
            right: 5px;
            font-size: 10px;
            color: gold;
        }
        .accept-btn {
            background: #90ee90;
            color: black;
            border: none;
            padding: 8px 20px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .decline-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 20px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .accept-btn:hover {
            background: #ff85c1;
        }
        .decline-btn:hover {
            background: #ff6666;
        }
        .roll-actions {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        button {
            background: #666;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            text-transform: lowercase;
        }
        button:hover {
            background: #888;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .button-container {
            text-align: center;
            margin-bottom: 30px;
        }
        .sections-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }
        @media (max-width: 900px) {
            .sections-container {
                grid-template-columns: 1fr;
            }
        }
        .upgrades-section, .inventory-section {
            margin-top: 20px;
        }
        .upgrades-header, .inventory-header, .enchants-header, .index-header {
            background: #666;
            color: white;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            margin-bottom: 10px;
            text-transform: lowercase;
        }
        .upgrades-header:hover, .inventory-header:hover, .enchants-header:hover, .index-header:hover {
            background: #888;
        }
        .upgrades-content, .inventory-content, .enchants-content, .index-content {
            display: none;
        }
        .upgrades-content.open, .inventory-content.open, .enchants-content.open, .index-content.open {
            display: block;
        }
        .upgrade-box {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ddd;
            margin-bottom: 10px;
        }
        .upgrade-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff69b4;
            text-transform: lowercase;
        }
        .upgrade-info {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        .inventory, .enchant-inventory {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .inventory-title, .enchant-title {
            font-weight: bold;
            font-size: 18px;
            color: #ff69b4;
            margin-bottom: 15px;
            text-transform: lowercase;
        }
        .inventory-item, .enchant-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border 0.3s;
            position: relative;
        }
        
        /* Inventory Outline Tiers */
        .inventory-item.tier-1 { 
            border: 3px solid white;
            border-top: 15px solid white;
        }
        .inventory-item.tier-2 { 
            border: 3px solid yellow;
            border-top: 15px solid yellow;
        }
        .inventory-item.tier-3 { 
            border: 3px solid blue;
            border-top: 15px solid blue;
        }
        .inventory-item.tier-4 { 
            border: 3px solid cyan;
            border-top: 15px solid cyan;
        }
        .inventory-item.tier-5 { 
            border: 3px solid orange;
            border-top: 15px solid orange;
        }
        .inventory-item.tier-6 { 
            border: 3px solid pink;
            border-top: 15px solid pink;
        }
        .inventory-item.tier-7 { 
            border: 3px solid lime;
            border-top: 15px solid lime;
        }
        .inventory-item.tier-8 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, gray, white, gray) 1;
            animation: spin-gradient 2s linear infinite;
        }
        .inventory-item.tier-9 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, #FFFF00, white, #FFFF00) 1;
            animation: spin-gradient 2s linear infinite;
        }
        .inventory-item.tier-10 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, purple, violet, purple, violet) 1;
            animation: spin-gradient 1s linear infinite;
        }
        .inventory-item.tier-11 { 
            border: 3px solid;
            border-top: 15px solid;
            border-image: linear-gradient(90deg, red, black, red) 1;
        }
        
        .tier-name {
            position: absolute;
            top: -17px;
            left: 10px;
            font-size: 10px;
            font-weight: bold;
            background: inherit;
            padding: 0 5px;
            color: inherit;
            text-transform: uppercase;
        }
        
        .tier-stars {
            position: absolute;
            bottom: -10px;
            right: 10px;
            font-size: 9px;
            color: gold;
            background: rgba(0,0,0,0.7);
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        @keyframes spin-gradient {
            0% { border-image-source: linear-gradient(0deg, gray, white, gray); }
            100% { border-image-source: linear-gradient(360deg, gray, white, gray); }
        }
        
        .inventory-rng {
            font-weight: bold;
            font-size: 16px;
        }
        .inventory-details {
            font-size: 14px;
            color: #666;
            text-transform: lowercase;
        }
        .index-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .index-category {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .index-title {
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 10px;
            border-bottom: 2px solid #ff69b4;
            padding-bottom: 5px;
            text-transform: lowercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .index-title::after {
            content: '‚ñº';
            font-size: 12px;
            transition: transform 0.3s;
        }
        .index-title.collapsed::after {
            transform: rotate(-90deg);
        }
        .index-items {
            max-height: 200px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }
        .index-items.collapsed {
            max-height: 0;
            overflow: hidden;
        }
        .index-item {
            margin-bottom: 5px;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
            text-transform: lowercase;
        }
        @keyframes flip {
            0% { transform: rotateX(0deg); }
            50% { transform: rotateX(180deg); }
            100% { transform: rotateX(360deg); }
        }
        .flipping {
            animation: flip 0.2s linear infinite;
        }
        .cube {
            display: inline-block;
            width: 80px;
            height: 80px;
            line-height: 80px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff69b4, #9370db);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            perspective: 1000px;
        }
        .equip-btn {
            background: #90ee90;
            color: black;
            border: none;
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
        }
        .unequip-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
        }
        .star-display {
            font-size: 16px;
            margin-bottom: 3px;
            color: gold;
        }
        .merge-section {
            margin-top: 20px;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            width: 200px;
        }
        .merge-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }
        .merge-select {
            padding: 5px;
            border-radius: 5px;
            border: 2px solid #ddd;
            font-size: 12px;
            width: 100%;
        }
        .merge-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
        .locked-enchant {
            opacity: 0.7;
            position: relative;
        }
        .locked-enchant::after {
            content: 'üîí';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
        }
        .autoroll-controls {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .autorow-toggle {
            background: #4CAF50;
            color: white;
        }
        .autorow-toggle.paused {
            background: #ff9800;
        }
        .autorow-toggle.stopped {
            background: #f44336;
        }
        .solar-rank {
            color: orange !important;
        }
        .completionist-rank {
            color: #00ffff !important;
        }
        .poly-squared-rank {
            color: #FF00FF !important;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .tickets-upgrades {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border: 2px solid #ffd700;
        }
        .tickets-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            font-size: 20px;
        }
        .spinner-section {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 2px dashed #9370db;
            text-align: center;
        }
        .wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 5px solid #ff69b4;
            margin: 15px auto;
            position: relative;
            overflow: hidden;
            transition: transform 3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .wheel-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            clip-path: polygon(50% 50%, 50% 0%, 100% 0%);
            transform-origin: 50% 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: black;
            text-align: center;
            font-weight: bold;
        }
        .wheel-pointer {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 20px solid #ff4444;
            z-index: 10;
        }
    </style>
</head>
<body>
    <button class="dark-mode-toggle" onclick="toggleDarkMode()">üåô Dark Mode</button>
    
    <div class="container">
        <h1>polys silly rngame</h1>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">polycoin</div>
                <div class="stat-value" id="polycoin">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">best roll</div>
                <div class="stat-value" id="best">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">total rolls</div>
                <div class="stat-value" id="rolls">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">enchants</div>
                <div class="stat-value" id="enchants">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">roll coins</div>
                <div class="stat-value" id="rollCoins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">tickets</div>
                <div class="stat-value" id="tickets">0</div>
            </div>
        </div>

        <div class="autoroll-controls">
            <button class="autorow-toggle" id="autorollBtn" onclick="toggleAutoroll()">‚ñ∂Ô∏è Start Autoroll</button>
            <div style="margin-top: 10px;">
                <label style="font-size: 14px; color: #666;">Pause on RNG ‚â• </label>
                <input type="number" id="pauseRNG" value="0" min="0" style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 14px; color: #666;">Pause on Secret Rarity ‚â• </label>
                <input type="number" id="pauseSecretRarity" value="0" min="0" style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 14px; color: #666;">Pause on Enchant Rarity ‚â• </label>
                <input type="number" id="pauseEnchantRarity" value="0" min="0" style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
        </div>

        <div class="cooldown-settings" style="text-align: center; margin-bottom: 20px; background: #f0f0f0; padding: 15px; border-radius: 10px;">
            <div style="display: inline-block; margin: 0 15px;">
                <label style="font-size: 14px; color: #666;">cooldown if RNG ‚â• </label>
                <input type="number" id="cooldownThreshold" value="0" min="0" step="1000" 
                    onchange="updateCooldownSettings()" 
                    style="width: 100px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
            <div style="display: inline-block; margin: 0 15px;">
                <label style="font-size: 14px; color: #666;">cooldown time (s): </label>
                <input type="number" id="cooldownTime" value="3" min="0.5" max="60" step="0.5" 
                    onchange="updateCooldownSettings()" 
                    style="width: 80px; padding: 5px; border-radius: 5px; border: 2px solid #ddd;">
            </div>
        </div>

        <div class="rollers-container" id="rollersContainer">
            <!-- rollers will be generated here -->
        </div>

        <div class="button-container">
            <button onclick="performRoll()" id="rollBtn">roll</button>
        </div>

        <div class="tickets-upgrades">
            <div class="tickets-title">üé´ Ticket Shop</div>
            <div class="upgrade-box">
                <div class="upgrade-title">min speed reduction</div>
                <div class="upgrade-info">level: <span id="minSpeedLevel">0</span>/4</div>
                <div class="upgrade-info">effect: -0.01s min roll speed</div>
                <button onclick="buyMinSpeedUpgrade()" id="minSpeedBtn">buy (cost: <span id="minSpeedCost">5</span> tickets)</button>
            </div>
            <div class="upgrade-box">
                <div class="upgrade-title">spinner unlock</div>
                <div class="upgrade-info">status: <span id="spinnerStatus">locked</span></div>
                <div class="upgrade-info">effect: unlock enchant spinner</div>
                <button onclick="buySpinner()" id="spinnerBtn" disabled>buy (cost: <span id="spinnerCost">10</span> tickets)</button>
            </div>
            <div class="upgrade-box">
                <div class="upgrade-title">ticket production</div>
                <div class="upgrade-info">level: <span id="ticketProdLevel">0</span>/2</div>
                <div class="upgrade-info">effect: +1 ticket per minute</div>
                <button onclick="buyTicketProduction()" id="ticketProdBtn">buy (cost: <span id="ticketProdCost">50</span> tickets)</button>
            </div>
            
            <div class="spinner-section" id="spinnerSection" style="display: none;">
                <div class="upgrade-title">üé° Enchant Spinner</div>
                <div class="wheel" id="spinnerWheel">
                    <div class="wheel-pointer"></div>
                </div>
                <button onclick="spinWheel()" id="spinBtn" disabled>Spin (5 tickets)</button>
                <div id="spinResult" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
            </div>
        </div>

        <div class="sections-container">
            <div class="left-column">
                <div class="upgrades-section">
                    <div class="upgrades-header" onclick="toggleSection('upgradesContent')">
                        ‚öôÔ∏è upgrades (click to expand) ‚öôÔ∏è
                    </div>
                    <div class="upgrades-content" id="upgradesContent">
                        <div class="upgrade-box">
                            <div class="upgrade-title">add roller</div>
                            <div class="upgrade-info">rollers: <span id="bulkLevel">1</span>/100</div>
                            <div class="upgrade-info">effect: +1 roller on screen</div>
                            <button onclick="buyUpgrade('bulk')" id="bulkBtn">buy (cost: <span id="bulkCost">100</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">luck boost</div>
                            <div class="upgrade-info">level: <span id="luckLevel">0</span>/100</div>
                            <div class="upgrade-info">effect: +<span id="luckAmount">0</span> luck</div>
                            <button onclick="buyUpgrade('luck')" id="luckBtn">buy (cost: <span id="luckCost">10</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">secret luck</div>
                            <div class="upgrade-info">level: <span id="secretLevel">0</span>/25</div>
                            <div class="upgrade-info">effect: +<span id="secretAmount">0</span> secret luck</div>
                            <button onclick="buyUpgrade('secret')" id="secretBtn">buy (cost: <span id="secretCost">50</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">roll speed</div>
                            <div class="upgrade-info">level: <span id="speedLevel">0</span>/25</div>
                            <div class="upgrade-info">speed: <span id="speedAmount">3.0</span>s</div>
                            <button onclick="buyUpgrade('speed')" id="speedBtn">buy (cost: <span id="speedCost">50</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">inventory slots</div>
                            <div class="upgrade-info">slots: <span id="invLevel">10</span>/50</div>
                            <div class="upgrade-info">effect: +1 inventory slot</div>
                            <button onclick="buyUpgrade('inventory')" id="invBtn">buy (cost: <span id="invCost">0</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">enchant luck</div>
                            <div class="upgrade-info">level: <span id="enchantLuckLevel">0</span>/15</div>
                            <div class="upgrade-info">effect: +<span id="enchantLuckAmount">0</span> enchant luck</div>
                            <button onclick="buyUpgrade('enchantLuck')" id="enchantLuckBtn">buy (cost: <span id="enchantLuckCost">30</span>)</button>
                        </div>
                        <div class="upgrade-box">
                            <div class="upgrade-title">variant luck</div>
                            <div class="upgrade-info">level: <span id="variantLuckLevel">0</span>/30</div>
                            <div class="upgrade-info">effect: +<span id="variantLuckAmount">0</span> variant luck</div>
                            <button onclick="buyUpgrade('variantLuck')" id="variantLuckBtn">buy (cost: <span id="variantLuckCost">50</span>)</button>
                        </div>
                    </div>
                </div>

                <div class="inventory-section">
                    <div class="inventory-header" onclick="toggleSection('inventoryContent')">
                        üì¶ inventory (<span id="invCount">0</span>/<span id="invMax">10</span>)
                    </div>
                    <div class="inventory-content open" id="inventoryContent">
                        <div class="inventory" id="inventoryList"></div>
                    </div>
                </div>

                <div class="merge-section">
                    <div class="inventory-title">üîÑ Enchant Merging</div>
                    <div class="merge-controls">
                        <select id="mergeOrb1" class="merge-select" onchange="updateMergePreview()">
                            <option value="-1">Select first orb</option>
                        </select>
                        <select id="mergeOrb2" class="merge-select" onchange="updateMergePreview()">
                            <option value="-1">Select second orb</option>
                        </select>
                        <button onclick="mergeEnchants()" id="mergeBtn" disabled>Merge (500 roll coins)</button>
                    </div>
                    <div class="merge-info" id="mergePreview">
                        Select two orbs to merge. Original orbs will be deleted.
                    </div>
                </div>
            </div>

            <div class="right-column">
                <div class="enchants-section">
                    <div class="enchants-header" onclick="toggleSection('enchantsContent')">
                        üîÆ enchants (<span id="enchantCount">0</span>)
                    </div>
                    <div class="enchants-content open" id="enchantsContent">
                        <div class="inventory-title">equipped orb</div>
                        <div class="inventory" id="equippedEnchant"></div>
                        <div class="inventory-title" style="margin-top: 15px;">enchant orbs</div>
                        <div class="inventory" id="enchantInventoryList"></div>
                    </div>
                </div>

                <div class="index-section">
                    <div class="index-header" onclick="toggleSection('indexContent')">
                        üìö index (click to expand)
                    </div>
                    <div class="index-content" id="indexContent">
                        <div class="index-grid">
                            <div class="index-category" onclick="toggleIndexCategory('variantsIndex')">
                                <div class="index-title">variants</div>
                                <div class="index-items" id="variantsIndexItems"></div>
                            </div>
                            <div class="index-category" onclick="toggleIndexCategory('normalRanksIndex')">
                                <div class="index-title">normal ranks</div>
                                <div class="index-items" id="normalRanksIndexItems"></div>
                            </div>
                            <div class="index-category" onclick="toggleIndexCategory('secretRanksIndex')">
                                <div class="index-title">secret ranks</div>
                                <div class="index-items" id="secretRanksIndexItems"></div>
                            </div>
                            <div class="index-category" onclick="toggleIndexCategory('enchantsIndex')">
                                <div class="index-title">enchants</div>
                                <div class="index-items" id="enchantsIndexItems"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Fix: Changed roll function name to performRoll to avoid conflict
        function performRoll() {
            roll();
        }

        // Helper function to format numbers
        function formatNumber(num) {
            if (num >= 1e9) {
                return num.toExponential(3);
            }
            return num.toLocaleString('en-US');
        }

        // game constants
        const VARIANTS = [
            { name: 'normal', chance: 1, multipliesRNG: 1 },
            { name: 'shiny', chance: 10, multipliesRNG: 10 },
            { name: 'better', chance: 25, multipliesRNG: 25 },
            { name: 'spectral', chance: 50, multipliesRNG: 50 },
            { name: 'divine', chance: 100, multipliesRNG: 100 },
            { name: 'chromatic', chance: 250, multipliesRNG: 250 },
            { name: 'inverted', chance: 500, multipliesRNG: 500 },
            { name: 'defined', chance: 1000, multipliesRNG: 1000 }
        ];

        const RANKS = [
            { name: 'common', min: 1, max: 5 },
            { name: 'rare', min: 5, max: 25 },
            { name: 'decent', min: 25, max: 50 },
            { name: 'natural', min: 50, max: 100 },
            { name: 'exceptional', min: 100, max: 250 },
            { name: 'eclipse', min: 250, max: 500 },
            { name: 'mythic', min: 500, max: 1000 },
            { name: 'divine', min: 1000, max: 5000 },
            { name: 'extraordinary', min: 5000, max: 10000 },
            { name: 'unreal', min: 10000, max: 50000 },
            { name: 'eternal', min: 50000, max: 100000 },
            { name: 'iridescence', min: 100000, max: 500000 },
            { name: 'zeta', min: 500000, max: 1000000 },
            { name: 'fantasy', min: 1000000, max: 2015510 },
            { name: 'giant', min: 2015510, max: 5000000 },
            { name: 'ultimate', min: 5000000, max: 1e7 },
            { name: 'apex', min: 1e7, max: 5e7 },
            { name: 'omega', min: 5e7, max: 1e8 },
            { name: 'insane', min: 1e8, max: 2.5e8 },
            { name: 'colossal', min: 2.5e8, max: 777777777 },
            { name: 'gargantuan', min: 777777777, max: 1e9 },
            { name: 'hyper', min: 1e9, max: 1e12 },
            { name: 'insurmountable', min: 1e12, max: 1e15 },
            { name: '(INFINITUDE)', min: 1e15, max: Infinity }
        ];

        const SECRETS = [
            { name: 'terrible', chance: 2500 },
            { name: 'weird', chance: 10000 },
            { name: 'best', chance: 20000 },
            { name: 'invisible', chance: 35300 },
            { name: 'grand', chance: 77777 },
            { name: 'defined', chance: 100000 },
            { name: '?!?!?', chance: 250000 },
            { name: 'nil', chance: 500000 },
            { name: 'infinity', chance: 1000000 },
            { name: 'imaginary', chance: 2500000 },
            { name: 'poly', chance: 5000000 },
            { name: ' ', chance: 7777777.777 },
            { name: 'evil rng !!!', chance: 9999999.99 },
            { name: 'ephermal', chance: 1e7 },
            { name: 'nuclear', chance: 25000000 },
            { name: 'theoretical', chance: 40000000 },
            { name: 'oblivion', chance: 66666666.66 },
            { name: 'everlasting', chance: 575265750 },
            { name: 'solar', chance: 100000 },
            { name: 'Completionist', chance: 1000000 },
            { name: 'poly¬≤', chance: 333333 } // Added poly¬≤
        ];

        const ENCHANT_TYPES = [
            { name: 'luck i', type: 'luck', value: 5, color: '#90ee90', chance: 1/1.5, priority: 1 },
            { name: 'luck ii', type: 'luck', value: 10, color: '#00ff00', chance: 1/5, priority: 2 },
            { name: 'insanity', type: 'luck', value: 50, color: '#00aa00', chance: 1/12500, priority: 3 },
            { name: 'speed i', type: 'speed', value: 0.25, color: '#87ceeb', chance: 1/2.5, priority: 1 },
            { name: 'speed ii', type: 'speed', value: 0.5, color: '#1e90ff', chance: 1/10, priority: 2 },
            { name: 'blitz', type: 'speed', value: 75, color: '#0066cc', chance: 1/17777, priority: 3 },
            { name: 'insight i', type: 'secret', value: 5, color: '#9370db', chance: 1/10, priority: 1 },
            { name: 'insight ii', type: 'secret', value: 25, color: '#8a2be2', chance: 1/50, priority: 2 },
            { name: 'omnipotence', type: 'secret', value: 125, color: '#6a0dad', chance: 1/25000, priority: 3 },
            { name: 'requiem i', type: 'requiem', value: 1, color: '#ff4500', chance: 1/500, priority: 1 },
            { name: 'requiem ii', type: 'requiem', value: 2, color: '#dc143c', chance: 1/10000, priority: 2 },
            { name: 'genesis', type: 'requiem', value: 3, color: '#8b0000', chance: 1/10000000, priority: 3 },
            { name: 'variant i', type: 'variant', value: 0.5, color: '#ffc0cb', chance: 1/25, priority: 1 },
            { name: 'variant ii', type: 'variant', value: 2.5, color: '#ff69b4', chance: 1/100, priority: 2 },
            { name: 'unusuality', type: 'variant', value: 20, color: '#ff1493', chance: 1/33333, priority: 3 },
            { name: 'addition i', type: 'addition', value: 1, color: '#ffaa00', chance: 1/25, priority: 1 },
            { name: 'addition ii', type: 'addition', value: 2, color: '#ff8800', chance: 1/75, priority: 2 },
            { name: 'endless', type: 'addition', value: 5, color: '#ff6600', chance: 1/5000, priority: 3 },
            { name: 'greed', type: 'greed', value: 1, color: '#ffd700', chance: 1/60, priority: 1 },
            { name: 'patience', type: 'patience', value: 1, color: '#00ced1', chance: 1/75, priority: 1 },
            { name: 'alpha', type: 'alpha', value: 1, color: '#00ffff', chance: 1/125, priority: 4 },
            { name: 'weird i', type: 'weird', value: 1.2, color: '#ff00ff', chance: 1/500, priority: 1 },
            { name: 'weird ii', type: 'weird', value: 2.5, color: '#cc00cc', chance: 1/2500, priority: 2 },
            { name: 'abnormal', type: 'weird', value: 12.5, color: '#990099', chance: 1/500000, priority: 3 },
            { name: 'overtime', type: 'overtime', baseLuck: 0.001, baseSpeed: 0.001, baseVariant: 0.001, baseSecret: 0.001, 
              currentLuck: 0.001, currentSpeed: 0.001, currentVariant: 0.001, currentSecret: 0.001, color: '#32CD32', chance: 1/5725, priority: 1 },
            { name: 'polys blessing', type: 'blessing', value: 0, color: '#FFD700', chance: 1/500000, priority: 5 },
            { name: 'delta', type: 'delta', value: 10, color: '#FF6347', chance: 1/89000, priority: 6 }
        ];

        // SPINNER REWARDS - FIXED AND ORGANIZED
        const SPINNER_REWARDS = [
            { name: 'luck ii', type: 'luck', value: 10, color: '#00ff00', weight: 40 },
            { name: 'speed ii', type: 'speed', value: 0.5, color: '#1e90ff', weight: 35 },
            { name: 'endless', type: 'addition', value: 5, color: '#ff6600', weight: 20 },
            { name: 'requiem ii', type: 'requiem', value: 2, color: '#dc143c', weight: 15 },
            { name: 'insanity', type: 'luck', value: 50, color: '#00aa00', weight: 10 },
            { name: 'weird ii', type: 'weird', value: 2.5, color: '#cc00cc', weight: 8 },
            { name: 'blitz', type: 'speed', value: 75, color: '#0066cc', weight: 5 },
            { name: 'genesis', type: 'requiem', value: 3, color: '#8b0000', weight: 2 },
            { name: 'combo', type: 'combo', value: 1, color: '#ff00ff', weight: 1 }
        ];

        // game state
        let polycoin = 0;
        let bestRoll = 0;
        let totalRolls = 0;
        let rollCoins = 0;
        let tickets = 0;
        let bulkLevel = 1;
        let bulkCost = 100;
        let luckLevel = 0;
        let luckCost = 10;
        let secretLevel = 0;
        let secretCost = 50;
        let speedLevel = 0;
        let speedCost = 50;
        let invLevel = 0;
        let invCost = 0;
        let enchantLuckLevel = 0;
        let enchantLuckCost = 30;
        let variantLuckLevel = 0;
        let variantLuckCost = 50;
        let minSpeedUpgrades = 0;
        let ticketProdLevel = 0;
        let ticketProdCost = 50;
        let spinnerUnlocked = false;
        let isRolling = false;
        let isAutorolling = false;
        let autorollInterval = null;
        let ticketInterval = null;
        let inventory = [];
        let enchantOrbs = [];
        let equippedOrb = null;
        let pendingRolls = {};
        let discovered = {
            variants: new Set(),
            ranks: new Set(),
            secrets: new Set(),
            enchants: new Set()
        };
        let cooldownThreshold = 0;
        let cooldownTime = 3;
        let pauseRNGThreshold = 0;
        let pauseSecretRarityThreshold = 0;
        let pauseEnchantRarityThreshold = 0;
        let overtimeRolls = {}; // Track rolls per overtime enchant

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const button = document.querySelector('.dark-mode-toggle');
            button.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
        }

        // Initialize dark mode
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
            document.querySelector('.dark-mode-toggle').textContent = '‚òÄÔ∏è Light Mode';
        }

        // load game on start
        loadGame();

        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            if (content) {
                content.classList.toggle('open');
            }
        }

        function toggleIndexCategory(categoryId) {
            const title = document.querySelector(`[onclick*="${categoryId}"] .index-title`);
            const items = document.getElementById(categoryId + 'Items');
            if (title && items) {
                title.classList.toggle('collapsed');
                items.classList.toggle('collapsed');
            }
        }

        function toggleAutoroll() {
            const btn = document.getElementById('autorollBtn');
            if (isAutorolling) {
                clearInterval(autorollInterval);
                isAutorolling = false;
                btn.textContent = '‚ñ∂Ô∏è Start Autoroll';
                btn.classList.remove('paused');
                btn.classList.add('stopped');
            } else {
                isAutorolling = true;
                btn.textContent = '‚è∏Ô∏è Pause Autoroll';
                btn.classList.remove('stopped');
                btn.classList.add('paused');
                
                autorollInterval = setInterval(() => {
                    if (!isRolling) {
                        roll();
                    }
                }, 100);
            }
        }

        function getRNGColor(rng, rankName) {
            if (rankName === 'solar') return 'orange';
            if (rankName === 'Completionist') return '#00ffff';
            if (rankName === 'poly¬≤') return '#FF00FF';
            if (rng < 1000) return '#aad7e6';
            if (rng < 10000) return '#ffc0cb';
            if (rng < 100000) return '#90ee90';
            if (rng < 1000000) return '#9370db';
            if (rng < 10000000) return 'linear-gradient(90deg, #ff0000, #ffffff)';
            if (rng < 100000000) return 'linear-gradient(90deg, #00ffff, #ffffff)';
            if (rng < 1000000000) return 'linear-gradient(90deg, #000000, #8b0000)';
            if (rng < 10000000000) return 'linear-gradient(25deg, #4ef542, #ffffff)';
            if (rng < 100000000000) return 'linear-gradient(45deg, #ff00ff, #00ffff, #ffffff)';
            if (rng < 1000000000000) return 'linear-gradient(135deg, #ff0000, #ff9900, #ffff00, #ffffff)';
            if (rng < 10000000000000) return 'linear-gradient(90deg, #0000ff, #00ff00, #ffff00, #ffffff)';
            if (rng < 100000000000000) return 'linear-gradient(120deg, #8b00ff, #ff00ff, #00ffff, #ffffff)';
            if (rng < 1000000000000000) return 'linear-gradient(180deg, #ff0000, #000000, #00ff00, #ffffff)';
            if (rng < 10000000000000000) return 'linear-gradient(225deg, #00ffff, #000000, #ffff00, #ffffff)';
            if (rng < 100000000000000000) return 'linear-gradient(270deg, #ff0000, #00ff00, #0000ff, #ffffff)';
            return 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
        }

        function getInventoryTier(finalRng) {
            if (finalRng >= 1 && finalRng < 1000) return { stars: 1, name: 'Common', color: 'white' };
            if (finalRng < 10000) return { stars: 2, name: 'Decent', color: 'yellow' };
            if (finalRng < 100000) return { stars: 3, name: 'Rare', color: 'blue' };
            if (finalRng < 1000000) return { stars: 4, name: 'Good', color: 'cyan' };
            if (finalRng < 100000000) return { stars: 5, name: 'Unordinary', color: 'orange' };
            if (finalRng < 1000000000) return { stars: 6, name: 'DAMN', color: 'pink' };
            if (finalRng < 100000000000) return { stars: 7, name: 'Insane', color: 'lime' };
            if (finalRng < 1000000000000) return { stars: 8, name: 'How', color: 'gray-white-gradient' };
            if (finalRng < 1e15) return { stars: 9, name: 'DAWG', color: 'yellow-white-gradient' };
            if (finalRng < 1e18) return { stars: 10, name: 'Lol', color: 'purple-violet-gradient' };
            return { stars: 11, name: 'STOP', color: 'red-black-gradient' };
        }

        function calculateRNG() {
            const luck = luckLevel * 0.5 + getTotalEnchantLuck();
            const rng = Math.random() ** (-1.3 - (luck * 0.01));
            return Math.max(1, rng);
        }

        function applyStarBonus(value, stars) {
            if (!stars || stars === 0) return value;
            return value * (1 + (stars * 0.2));
        }

        function getTotalEnchantLuck() {
            let total = 0;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'luck') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total += applyStarBonus(0.25, stars);
                if (enchant.type === 'delta') total += applyStarBonus(2.5, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(5, stars);
                    else if (enchant.value === 2) total += applyStarBonus(10, stars);
                    else if (enchant.value === 3) total += applyStarBonus(50, stars);
                }
                if (enchant.type === 'greed') total -= applyStarBonus(20, stars);
                if (enchant.type === 'patience') total += applyStarBonus(100, stars);
                if (enchant.type === 'overtime') total += applyStarBonus(enchant.currentLuck, stars);
            });
            
            return total;
        }

        function getTotalEnchantSecret() {
            let total = 0;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'secret') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total += applyStarBonus(0.5, stars);
                if (enchant.type === 'delta') total += applyStarBonus(5, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(5, stars);
                    else if (enchant.value === 2) total += applyStarBonus(25, stars);
                    else if (enchant.value === 3) total += applyStarBonus(125, stars);
                }
                if (enchant.type === 'overtime') total += applyStarBonus(enchant.currentSecret, stars);
            });
            
            return total;
        }

        function getTotalEnchantSpeed() {
            let total = 0;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'speed') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total -= applyStarBonus(0.05, stars);
                if (enchant.type === 'delta') total -= applyStarBonus(0.5, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(0.25, stars);
                    else if (enchant.value === 2) total += applyStarBonus(0.5, stars);
                    else if (enchant.value === 3) total += applyStarBonus(75, stars);
                }
                if (enchant.type === 'greed') total -= applyStarBonus(0.7, stars);
                if (enchant.type === 'patience') total -= applyStarBonus(25, stars);
                if (enchant.type === 'overtime') total += applyStarBonus(enchant.currentSpeed, stars);
            });
            
            return total;
        }

        function getTotalEnchantVariant() {
            let total = variantLuckLevel * 0.05;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'variant') total += applyStarBonus(enchant.value, stars);
                if (enchant.type === 'alpha') total += applyStarBonus(0.125, stars);
                if (enchant.type === 'delta') total += applyStarBonus(1.25, stars);
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += applyStarBonus(0.5, stars);
                    else if (enchant.value === 2) total += applyStarBonus(2.5, stars);
                    else if (enchant.value === 3) total += applyStarBonus(20, stars);
                }
                if (enchant.type === 'patience') total += applyStarBonus(5, stars);
                if (enchant.type === 'overtime') total += applyStarBonus(enchant.currentVariant, stars);
            });
            
            return total;
        }

        function getTotalEnchantLuckBonus() {
            let total = enchantLuckLevel * 0.05;
            if (!equippedOrb) return total;
            
            const stars = equippedOrb.stars || 0;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'weird') total += applyStarBonus(enchant.value, stars);
            });
            
            return total;
        }

        function getTotalBulkRolls() {
            let total = Math.min(bulkLevel, 100);
            
            if (!equippedOrb) return total;
            
            equippedOrb.enchants.forEach(enchant => {
                if (enchant.type === 'addition') total += enchant.value;
                if (enchant.type === 'greed') total += 2;
                if (enchant.type === 'patience') total += 3;
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) total += 1;
                    else if (enchant.value === 2) total += 2;
                    else if (enchant.value === 3) total += 5;
                }
            });
            
            return Math.min(total, 100);
        }

        function getRank(rng) {
            for (let i = RANKS.length - 1; i >= 0; i--) {
                if (rng >= RANKS[i].min) {
                    return RANKS[i].name;
                }
            }
            return RANKS[0].name;
        }

        function getVariant() {
            const variantLuck = getTotalEnchantVariant();
            for (let i = VARIANTS.length - 1; i >= 0; i--) {
                const adjustedChance = VARIANTS[i].chance / (1 + variantLuck);
                const random = Math.random();
                if (random <= 1 / adjustedChance) {
                    return VARIANTS[i];
                }
            }
            return VARIANTS[0];
        }

        function checkSecret(baseRng, hasPolyBlessing) {
            const secretLuck = secretLevel * 0.2 + getTotalEnchantSecret();
            const random = Math.random();
            
            // Check if all normal ranks are discovered for Completionist
            let allNormalRanksDiscovered = true;
            for (const rank of RANKS) {
                if (!discovered.ranks.has(rank.name)) {
                    allNormalRanksDiscovered = false;
                    break;
                }
            }
            
            // Check for poly¬≤ if player has polys blessing equipped
            if (hasPolyBlessing && random <= 1/333333) {
                return 'poly¬≤';
            }
            
            // FIXED: Solar only replaces eclipse (250-500 RNG)
            const currentRank = getRank(baseRng);
            if (currentRank === 'eclipse' && random <= 1/100000) {
                return 'solar';
            }
            
            // Special handling for Completionist - always rollable when all normal ranks discovered
            if (allNormalRanksDiscovered && random <= 1/1000000) {
                return 'Completionist';
            }
            
            for (let i = SECRETS.length - 1; i >= 0; i--) {
                // Skip Completionist, solar and poly¬≤ if we already handled them
                if (SECRETS[i].name === 'Completionist' || SECRETS[i].name === 'solar' || SECRETS[i].name === 'poly¬≤') continue;
                
                const adjustedChance = SECRETS[i].chance / (1 + secretLuck);
                if (random <= 1 / adjustedChance) {
                    return SECRETS[i].name;
                }
            }
            return null;
        }

        function shouldOverrideEnchant(enchantName) {
            const overrideExceptions = ['requiem i', 'requiem ii', 'genesis', 'blitz', 'omnipotence', 'endless', 'abnormal', 'unusuality', 'overtime', 'polys blessing', 'delta'];
            return !overrideExceptions.includes(enchantName.toLowerCase());
        }

        function generateEnchants(baseRng) {
            if (baseRng < 500) return [];
            
            const generated = {};
            const enchantLuck = getTotalEnchantLuckBonus();
            
            // Check for delta first (higher priority than alpha)
            const deltaChance = ENCHANT_TYPES.find(e => e.name === 'delta').chance * (1 + enchantLuck);
            let hasDelta = false;
            if (Math.random() <= deltaChance) {
                hasDelta = true;
                const deltaEnchant = ENCHANT_TYPES.find(e => e.name === 'delta');
                generated['delta'] = {
                    name: deltaEnchant.name,
                    type: deltaEnchant.type,
                    value: deltaEnchant.value,
                    color: deltaEnchant.color,
                    priority: deltaEnchant.priority
                };
            }
            
            // Check for alpha if no delta
            const alphaChance = ENCHANT_TYPES.find(e => e.name === 'alpha').chance * (1 + enchantLuck);
            let hasAlpha = false;
            if (!hasDelta && Math.random() <= alphaChance) {
                hasAlpha = true;
                const alphaEnchant = ENCHANT_TYPES.find(e => e.name === 'alpha');
                generated['alpha'] = {
                    name: alphaEnchant.name,
                    type: alphaEnchant.type,
                    value: alphaEnchant.value,
                    color: alphaEnchant.color,
                    priority: alphaEnchant.priority
                };
            }
            
            // Generate other enchants (skip if alpha or delta overrides them)
            ENCHANT_TYPES.forEach(enchant => {
                if (enchant.name === 'alpha' || enchant.name === 'delta') return;
                
                if ((hasAlpha || hasDelta) && shouldOverrideEnchant(enchant.name)) {
                    return;
                }
                
                const adjustedChance = enchant.chance * (1 + enchantLuck);
                if (Math.random() <= adjustedChance) {
                    if (enchant.name === 'overtime') {
                        // Create a deep copy for overtime to track its own stats
                        generated['overtime'] = {
                            name: enchant.name,
                            type: enchant.type,
                            baseLuck: enchant.baseLuck,
                            baseSpeed: enchant.baseSpeed,
                            baseVariant: enchant.baseVariant,
                            baseSecret: enchant.baseSecret,
                            currentLuck: enchant.baseLuck,
                            currentSpeed: enchant.baseSpeed,
                            currentVariant: enchant.baseVariant,
                            currentSecret: enchant.baseSecret,
                            color: enchant.color,
                            priority: enchant.priority
                        };
                    } else if (!generated[enchant.type] || generated[enchant.type].priority < enchant.priority) {
                        generated[enchant.type] = {
                            name: enchant.name,
                            type: enchant.type,
                            value: enchant.value,
                            color: enchant.color,
                            priority: enchant.priority
                        };
                    }
                }
            });
            
            return Object.values(generated).sort((a, b) => a.type.localeCompare(b.type));
        }

        function generateStars(hasEnchants) {
            if (!hasEnchants) return 0;
            
            if (Math.random() > 1/3) return 0;
            
            const starRolls = [
                { stars: 1, chance: 1/1 },
                { stars: 2, chance: 1/3 },
                { stars: 3, chance: 1/6 },
                { stars: 4, chance: 1/9 },
                { stars: 5, chance: 1/12 }
            ];
            
            for (let i = starRolls.length - 1; i >= 0; i--) {
                if (Math.random() <= starRolls[i].chance) {
                    return starRolls[i].stars;
                }
            }
            
            return 1;
        }

        function updateRollers() {
            const container = document.getElementById('rollersContainer');
            container.innerHTML = '';
            const totalRollers = getTotalBulkRolls();
            for (let i = 0; i < totalRollers; i++) {
                const roller = document.createElement('div');
                roller.className = 'roll-display';
                roller.id = `roller-${i}`;
                roller.innerHTML = `
                    <div class="variant-box"></div>
                    <div class="rng-box">
                        <div class="roll-result">press roll!</div>
                        <div class="roll-name"></div>
                    </div>
                    <div class="enchants-box">
                        <div class="star-indicator" style="display: none;"></div>
                    </div>
                    <div class="roll-actions" style="display: none;">
                        <button class="accept-btn" onclick="acceptRoll(${i})">‚úì accept</button>
                        <button class="decline-btn" onclick="declineRoll(${i})">‚úó decline</button>
                    </div>
                `;
                container.appendChild(roller);
            }
        }

        function animateRoller(index) {
            const roller = document.getElementById(`roller-${index}`);
            if (!roller) return;
            
            const resultEl = roller.querySelector('.roll-result');
            const variantBox = roller.querySelector('.variant-box');
            const nameEl = roller.querySelector('.roll-name');
            const enchantsBox = roller.querySelector('.enchants-box');
            
            resultEl.classList.add('flipping');
            variantBox.textContent = '';
            nameEl.textContent = '';
            enchantsBox.innerHTML = '<div class="star-indicator" style="display: none;"></div>';
            
            resultEl.innerHTML = '';
            
            const cube = document.createElement('div');
            cube.className = 'cube flipping';
            resultEl.appendChild(cube);
            
            let animationCount = 0;
            const maxAnimations = 15;
            
            function updateAnimation() {
                if (animationCount >= maxAnimations) {
                    return;
                }
                
                const animatedRNG = Math.random() ** (-1.3);
                cube.textContent = Math.floor(Math.max(1, animatedRNG * 10));
                
                animationCount++;
                if (animationCount < maxAnimations) {
                    setTimeout(updateAnimation, 150);
                }
            }
            
            updateAnimation();
        }

        function displayRoll(index, baseRng, finalRng, rankName, variantName, generatedEnchants, stars) {
            const roller = document.getElementById(`roller-${index}`);
            if (!roller) return;
            
            const resultEl = roller.querySelector('.roll-result');
            const variantBox = roller.querySelector('.variant-box');
            const nameEl = roller.querySelector('.roll-name');
            const enchantsBox = roller.querySelector('.enchants-box');
            const starIndicator = enchantsBox.querySelector('.star-indicator');
            const actionElements = roller.querySelector('.roll-actions');
            
            resultEl.classList.remove('flipping');
            resultEl.textContent = formatNumber(finalRng);
            
            variantBox.textContent = variantName;
            nameEl.textContent = rankName;
            
            if (generatedEnchants && generatedEnchants.length > 0 && stars && stars > 0) {
                starIndicator.textContent = '‚≠ê'.repeat(stars);
                starIndicator.style.display = 'block';
            } else {
                starIndicator.style.display = 'none';
            }
            
            if (generatedEnchants && generatedEnchants.length > 0) {
                enchantsBox.innerHTML = generatedEnchants.map(enchant => 
                    `<span class="enchant-tag" style="background: ${enchant.color}">${enchant.name}</span>`
                ).join('');
                if (stars && stars > 0) {
                    enchantsBox.appendChild(starIndicator);
                }
            } else {
                enchantsBox.innerHTML = '';
                starIndicator.style.display = 'none';
            }
            
            actionElements.style.display = 'flex';
            
            const color = getRNGColor(finalRng, rankName);
            if (color.includes('gradient')) {
                resultEl.style.background = color;
                resultEl.style.webkitBackgroundClip = 'text';
                resultEl.style.webkitTextFillColor = 'transparent';
                resultEl.style.backgroundClip = 'text';
            } else {
                resultEl.style.background = 'none';
                resultEl.style.webkitTextFillColor = 'inherit';
                resultEl.style.color = color;
            }
            
            if (rankName === 'solar') {
                resultEl.classList.add('solar-rank');
            } else if (rankName === 'Completionist') {
                resultEl.classList.add('completionist-rank');
            } else if (rankName === 'poly¬≤') {
                resultEl.classList.add('poly-squared-rank');
            } else {
                resultEl.classList.remove('solar-rank');
                resultEl.classList.remove('completionist-rank');
                resultEl.classList.remove('poly-squared-rank');
            }
        }

        function acceptRoll(index) {
            if (!pendingRolls[index]) return;
            
            const maxSlots = 10 + invLevel;
            if (inventory.length >= maxSlots) {
                alert('inventory is full! buy more slots or decline some rolls.');
                return;
            }
            
            inventory.unshift(pendingRolls[index]);
            
            // Create enchant orb if there are ANY enchants, even without stars
            if (pendingRolls[index].enchants && pendingRolls[index].enchants.length > 0) {
                const stars = pendingRolls[index].stars || 0;
                const orb = {
                    id: Date.now() + Math.random(),
                    enchants: pendingRolls[index].enchants.map(enchant => {
                        if (enchant.type === 'overtime') {
                            return {
                                name: enchant.name,
                                type: enchant.type,
                                baseLuck: enchant.baseLuck,
                                baseSpeed: enchant.baseSpeed,
                                baseVariant: enchant.baseVariant,
                                baseSecret: enchant.baseSecret,
                                currentLuck: enchant.currentLuck,
                                currentSpeed: enchant.currentSpeed,
                                currentVariant: enchant.currentVariant,
                                currentSecret: enchant.currentSecret,
                                color: enchant.color,
                                priority: enchant.priority
                            };
                        }
                        return { ...enchant };
                    }),
                    sourceRNG: pendingRolls[index].finalRng,
                    variant: pendingRolls[index].variant,
                    stars: stars,
                    locked: false,
                    rollsWithOvertime: 0
                };
                enchantOrbs.push(orb);
            }
            
            delete pendingRolls[index];
            
            const roller = document.getElementById(`roller-${index}`);
            if (roller) {
                const actionElements = roller.querySelector('.roll-actions');
                actionElements.style.display = 'none';
            }
            
            updateInventory();
            updateEnchantInventory();
            updateMergeSelects();
            updateUI();
            saveGame();
        }

        function declineRoll(index) {
            if (!pendingRolls[index]) return;
            
            delete pendingRolls[index];
            
            const roller = document.getElementById(`roller-${index}`);
            if (roller) {
                const actionElements = roller.querySelector('.roll-actions');
                actionElements.style.display = 'none';
            }
        }

        function deleteInventoryItem(index) {
            inventory.splice(index, 1);
            updateInventory();
            saveGame();
        }

        function deleteEnchantOrb(index) {
            if (equippedOrb && enchantOrbs[index].id === equippedOrb.id) {
                equippedOrb = null;
            }
            enchantOrbs.splice(index, 1);
            updateEnchantInventory();
            updateMergeSelects();
            updateUI();
            updateRollers();
            saveGame();
        }

        function equipEnchantOrb(index) {
            equippedOrb = enchantOrbs[index];
            
            // Initialize overtime rolls tracking if not exists
            if (!equippedOrb.rollsWithOvertime) {
                equippedOrb.rollsWithOvertime = 0;
            }
            
            updateEnchantInventory();
            updateUI();
            updateRollers();
            saveGame();
        }

        function unequipEnchantOrb() {
            equippedOrb = null;
            updateEnchantInventory();
            updateUI();
            updateRollers();
            saveGame();
        }

        function roll() {
            if (isRolling) return;
            
            isRolling = true;
            document.getElementById('rollBtn').disabled = true;
            
            const totalRollers = getTotalBulkRolls();
            for (let i = 0; i < totalRollers; i++) {
                animateRoller(i);
            }
            
            const baseSpeed = 3;
            const speedReduction = speedLevel * 0.1 + getTotalEnchantSpeed();
            const minRollSpeed = Math.max(0.05 - (minSpeedUpgrades * 0.01), 0.01);
            const rollSpeed = Math.max(minRollSpeed, baseSpeed - speedReduction);
            
            setTimeout(() => {
                let maxRoll = 0;
                let foundSecretToPause = false;
                let foundEnchantToPause = false;
                
                for (let i = 0; i < totalRollers; i++) {
                    let baseRng = calculateRNG();
                    
                    // Check if player has polys blessing equipped
                    const hasPolyBlessing = equippedOrb && equippedOrb.enchants && 
                        equippedOrb.enchants.some(e => e.name === 'polys blessing');
                    
                    let secret = checkSecret(baseRng, hasPolyBlessing);
                    
                    // Handle special secrets
                    if (secret === 'poly¬≤') {
                        finalRng = -2932932; // Special value for poly¬≤
                        baseRng = -2932932;
                    } else if (secret === 'solar') {
                        baseRng *= 100000;
                    } else if (secret === 'Completionist') {
                        baseRng = -500;
                    }
                    
                    const variant = getVariant();
                    const finalRng = secret === 'Completionist' ? -500 : 
                                   secret === 'poly¬≤' ? -2932932 : 
                                   baseRng * variant.multipliesRNG;
                    
                    if (finalRng > maxRoll) maxRoll = finalRng;
                    
                    const rankName = secret || getRank(baseRng);
                    
                    discovered.variants.add(variant.name);
                    discovered.ranks.add(rankName);
                    if (secret) discovered.secrets.add(secret);
                    
                    const gain = (secret === 'Completionist' || secret === 'poly¬≤') ? 0 : Math.floor(Math.pow(finalRng, 0.8) * 0.75);
                    polycoin += gain;
                    rollCoins += 1;
                    totalRolls++;
                    
                    if (finalRng > bestRoll && secret !== 'Completionist' && secret !== 'poly¬≤') {
                        bestRoll = finalRng;
                    }
                    
                    const generatedEnchants = generateEnchants(baseRng);
                    generatedEnchants.forEach(e => discovered.enchants.add(e.name));
                    
                    // Update Overtime enchant if equipped
                    if (equippedOrb && equippedOrb.enchants) {
                        equippedOrb.enchants.forEach(enchant => {
                            if (enchant.type === 'overtime') {
                                // Increment rolls counter
                                if (!equippedOrb.rollsWithOvertime) {
                                    equippedOrb.rollsWithOvertime = 0;
                                }
                                equippedOrb.rollsWithOvertime++;
                                
                                // Increase all stats by 0.001
                                enchant.currentLuck += 0.001;
                                enchant.currentSpeed += 0.001;
                                enchant.currentVariant += 0.001;
                                enchant.currentSecret += 0.001;
                            }
                        });
                    }
                    
                    const stars = generatedEnchants.length > 0 ? generateStars(true) : 0;
                    displayRoll(i, baseRng, finalRng, rankName, variant.name, generatedEnchants, stars);
                    
                    pendingRolls[i] = {
                        baseRng: baseRng,
                        finalRng: finalRng,
                        rank: rankName,
                        variant: variant.name,
                        enchants: generatedEnchants,
                        stars: stars,
                        timestamp: Date.now()
                    };
                    
                    // Check for pause conditions
                    pauseRNGThreshold = parseFloat(document.getElementById('pauseRNG').value) || 0;
                    pauseSecretRarityThreshold = parseFloat(document.getElementById('pauseSecretRarity').value) || 0;
                    pauseEnchantRarityThreshold = parseFloat(document.getElementById('pauseEnchantRarity').value) || 0;
                    
                    // Check enchant rarity for pause
                    if (pauseEnchantRarityThreshold > 0 && generatedEnchants.length > 0) {
                        generatedEnchants.forEach(enchant => {
                            const enchantType = ENCHANT_TYPES.find(e => e.name === enchant.name);
                            if (enchantType) {
                                const rarity = 1 / enchantType.chance;
                                if (rarity >= pauseEnchantRarityThreshold) {
                                    foundEnchantToPause = true;
                                }
                            }
                        });
                    }
                    
                    if (isAutorolling && pauseRNGThreshold > 0 && finalRng >= pauseRNGThreshold) {
                        toggleAutoroll();
                        alert(`Autoroll paused! Found roll with RNG ‚â• ${formatNumber(pauseRNGThreshold)}.`);
                    }
                    
                    if (isAutorolling && pauseSecretRarityThreshold > 0 && secret) {
                        const secretObj = SECRETS.find(s => s.name === secret);
                        if (secretObj && secretObj.chance >= pauseSecretRarityThreshold) {
                            foundSecretToPause = true;
                        }
                    }
                }
                
                if (foundSecretToPause && isAutorolling) {
                    toggleAutoroll();
                    alert(`Autoroll paused! Found secret with rarity ‚â• ${formatNumber(pauseSecretRarityThreshold)}.`);
                }
                
                if (foundEnchantToPause && isAutorolling) {
                    toggleAutoroll();
                    alert(`Autoroll paused! Found enchant with rarity ‚â• ${formatNumber(pauseEnchantRarityThreshold)}.`);
                }
                
                updateUI();
                updateIndex();
                saveGame();
                isRolling = false;
                
                if (cooldownThreshold > 0 && maxRoll >= cooldownThreshold) {
                    let countdown = cooldownTime;
                    const rollBtn = document.getElementById('rollBtn');
                    rollBtn.textContent = `cooldown: ${countdown.toFixed(1)}s`;
                    
                    const interval = setInterval(() => {
                        countdown -= 0.1;
                        if (countdown <= 0) {
                            clearInterval(interval);
                            rollBtn.textContent = 'roll';
                            rollBtn.disabled = false;
                        } else {
                            rollBtn.textContent = `cooldown: ${countdown.toFixed(1)}s`;
                        }
                    }, 100);
                } else {
                    document.getElementById('rollBtn').disabled = false;
                }
            }, rollSpeed * 1000);
        }

        function buyUpgrade(type) {
            if (type === 'bulk') {
                if (bulkLevel >= 100 || polycoin < bulkCost) return;
                polycoin -= bulkCost;
                bulkLevel++;
                bulkCost *= 100;
                updateRollers();
            } else if (type === 'luck') {
                if (luckLevel >= 100 || polycoin < luckCost) return;
                polycoin -= luckCost;
                luckLevel++;
                luckCost = Math.floor(luckCost * 1.15);
            } else if (type === 'secret') {
                if (secretLevel >= 25 || polycoin < secretCost) return;
                polycoin -= secretCost;
                secretLevel++;
                secretCost = Math.floor(secretCost * 1.3333);
            } else if (type === 'speed') {
                if (speedLevel >= 25 || polycoin < speedCost) return;
                polycoin -= speedCost;
                speedLevel++;
                speedCost = Math.floor(speedCost * 1.15);
            } else if (type === 'inventory') {
                const nextInvCost = calculateInvCost();
                if (invLevel >= 40 || polycoin < nextInvCost) return;
                polycoin -= nextInvCost;
                invLevel++;
            } else if (type === 'enchantLuck') {
                if (enchantLuckLevel >= 15 || polycoin < enchantLuckCost) return;
                polycoin -= enchantLuckCost;
                enchantLuckLevel++;
                enchantLuckCost = Math.floor(enchantLuckCost * 1.175);
            } else if (type === 'variantLuck') {
                if (variantLuckLevel >= 30 || polycoin < variantLuckCost) return;
                polycoin -= variantLuckCost;
                variantLuckLevel++;
                variantLuckCost = Math.floor(variantLuckCost * 1.2);
            }
            updateUI();
            saveGame();
        }

        function buyMinSpeedUpgrade() {
            if (minSpeedUpgrades >= 4 || tickets < 5) return;
            tickets -= 5;
            minSpeedUpgrades++;
            updateUI();
            saveGame();
        }

        function buyTicketProduction() {
            if (ticketProdLevel >= 2 || tickets < ticketProdCost) return;
            tickets -= ticketProdCost;
            ticketProdLevel++;
            ticketProdCost *= 10;
            startTicketTimer(); // Restart timer with new rate
            updateUI();
            saveGame();
        }

        function buySpinner() {
            if (spinnerUnlocked || tickets < 10) return;
            tickets -= 10;
            spinnerUnlocked = true;
            document.getElementById('spinnerSection').style.display = 'block';
            document.getElementById('spinBtn').disabled = tickets < 5;
            createSpinnerWheel();
            updateUI();
            saveGame();
        }

        function createSpinnerWheel() {
            const wheel = document.getElementById('spinnerWheel');
            wheel.innerHTML = '<div class="wheel-pointer"></div>';
            
            // Calculate total weight
            const totalWeight = SPINNER_REWARDS.reduce((sum, reward) => sum + reward.weight, 0);
            let startAngle = 0;
            
            SPINNER_REWARDS.forEach((reward, index) => {
                const segmentAngle = (reward.weight / totalWeight) * 360;
                const segment = document.createElement('div');
                segment.className = 'wheel-segment';
                segment.style.backgroundColor = reward.color;
                segment.style.transform = `rotate(${startAngle}deg)`;
                
                // Create text element that will be properly rotated
                const textDiv = document.createElement('div');
                textDiv.textContent = reward.name;
                textDiv.style.transform = `rotate(${segmentAngle/2}deg) translate(70px) rotate(-${segmentAngle/2}deg)`;
                textDiv.style.fontSize = '11px';
                textDiv.style.fontWeight = 'bold';
                textDiv.style.color = 'black';
                textDiv.style.textAlign = 'center';
                textDiv.style.width = '40px';
                
                segment.appendChild(textDiv);
                wheel.appendChild(segment);
                startAngle += segmentAngle;
            });
        }

        function spinWheel() {
            if (!spinnerUnlocked || tickets < 5) return;
            
            tickets -= 5;
            const spinBtn = document.getElementById('spinBtn');
            const resultDiv = document.getElementById('spinResult');
            
            spinBtn.disabled = true;
            resultDiv.textContent = 'Spinning...';
            
            const wheel = document.getElementById('spinnerWheel');
            const spinDuration = 3000 + Math.random() * 1000;
            const spins = 5 + Math.random() * 3;
            const totalRotation = 360 * spins + Math.random() * 360;
            
            wheel.style.transition = `transform ${spinDuration}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
            wheel.style.transform = `rotate(${totalRotation}deg)`;
            
            setTimeout(() => {
                // Calculate total weight
                const totalWeight = SPINNER_REWARDS.reduce((sum, reward) => sum + reward.weight, 0);
                
                // Normalize the rotation to 0-360
                const normalizedRotation = totalRotation % 360;
                
                // Find which segment the pointer is pointing to
                let cumulativeAngle = 0;
                let winningIndex = 0;
                let segmentAngles = [];
                
                // Calculate segment angles
                SPINNER_REWARDS.forEach(reward => {
                    segmentAngles.push((reward.weight / totalWeight) * 360);
                });
                
                // The pointer is at the top (0 degrees), so we need to check from 360 backwards
                const pointerAngle = (360 - normalizedRotation + 360) % 360;
                
                for (let i = 0; i < segmentAngles.length; i++) {
                    cumulativeAngle += segmentAngles[i];
                    if (pointerAngle <= cumulativeAngle) {
                        winningIndex = i;
                        break;
                    }
                }
                
                const reward = SPINNER_REWARDS[winningIndex];
                
                let enchants = [];
                if (reward.name === 'combo') {
                    enchants = [
                        { name: 'luck ii', type: 'luck', value: 10, color: '#00ff00', priority: 2 },
                        { name: 'speed ii', type: 'speed', value: 0.5, color: '#1e90ff', priority: 2 },
                        { name: 'insight i', type: 'secret', value: 5, color: '#9370db', priority: 1 }
                    ];
                } else {
                    enchants = [{
                        name: reward.name,
                        type: reward.type,
                        value: reward.value,
                        color: reward.color,
                        priority: reward.priority || 1
                    }];
                }
                
                const stars = generateStars(true);
                const orb = {
                    id: Date.now() + Math.random(),
                    enchants: enchants,
                    sourceRNG: 0,
                    variant: 'spinner',
                    stars: stars,
                    locked: false
                };
                
                enchantOrbs.push(orb);
                updateEnchantInventory();
                updateMergeSelects();
                updateUI();
                saveGame();
                
                resultDiv.innerHTML = `Won: <strong style="color: ${reward.color}">${reward.name}</strong>${stars > 0 ? ' with ' + '‚≠ê'.repeat(stars) + ' stars' : ''}!`;
                spinBtn.disabled = tickets < 5;
                
                setTimeout(() => {
                    wheel.style.transition = 'none';
                    wheel.style.transform = 'rotate(0deg)';
                    setTimeout(() => {
                        wheel.style.transition = `transform ${spinDuration}ms cubic-bezier(0.34, 1.56, 0.64, 1)`;
                    }, 50);
                }, 1000);
            }, spinDuration);
        }

        function updateInventory() {
            const list = document.getElementById('inventoryList');
            const maxSlots = 10 + invLevel;
            
            document.getElementById('invCount').textContent = formatNumber(inventory.length);
            document.getElementById('invMax').textContent = formatNumber(maxSlots);
            
            if (inventory.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: #999;">no accepted rolls yet!</div>';
                return;
            }
            
            list.innerHTML = inventory.map((item, index) => {
                const color = getRNGColor(item.finalRng, item.rank);
                let style = `color: ${color};`;
                if (color.includes('gradient')) {
                    style = `background: ${color}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;`;
                }
                
                const enchantsHTML = item.enchants && item.enchants.length > 0 
                    ? `<div style="font-size: 12px; color: #666;">+${item.enchants.length} enchants</div>`
                    : '';
                
                const starsHTML = item.stars && item.stars > 0 
                    ? `<div style="font-size: 11px; color: gold;">${'‚≠ê'.repeat(item.stars)}</div>`
                    : '';
                
                // Apply inventory tier border
                const tier = getInventoryTier(item.finalRng);
                const tierClass = `tier-${tier.stars}`;
                
                return `
                    <div class="inventory-item ${tierClass} ${item.rank === 'solar' ? 'solar-rank' : item.rank === 'Completionist' ? 'completionist-rank' : item.rank === 'poly¬≤' ? 'poly-squared-rank' : ''}">
                        <div class="tier-name">${tier.name}</div>
                        <div class="tier-stars">${tier.stars}‚òÖ</div>
                        <div>
                            <span class="inventory-rng" style="${style}">${formatNumber(item.finalRng)}</span>
                            <div class="inventory-details">${item.rank} - ${item.variant} (x${formatNumber(Math.round(item.finalRng/item.baseRng))})</div>
                            ${starsHTML}
                            ${enchantsHTML}
                        </div>
                        <button class="decline-btn" onclick="deleteInventoryItem(${index})" style="padding: 5px 15px; font-size: 12px;">delete</button>
                    </div>
                `;
            }).join('');
        }

        function getEnchantDescription(enchant, stars = 0) {
            const starBonus = stars > 0 ? ` (${1 + stars * 0.2}x)` : '';
            
            if (enchant.type === 'luck') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(1)} luck${starBonus}`;
            }
            if (enchant.type === 'speed') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(2)}s speed${starBonus}`;
            }
            if (enchant.type === 'secret') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(1)} secret${starBonus}`;
            }
            if (enchant.type === 'variant') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(1)} variant luck${starBonus}`;
            }
            if (enchant.type === 'addition') return `+${enchant.value} bulk roll`;
            if (enchant.type === 'requiem') {
                if (enchant.value === 1) {
                    const luck = applyStarBonus(5, stars);
                    const speed = applyStarBonus(0.25, stars);
                    const secret = applyStarBonus(5, stars);
                    const variant = applyStarBonus(0.5, stars);
                    return `+${luck.toFixed(1)} luck, +${speed.toFixed(2)}s speed, +${secret.toFixed(1)} secret, +${variant.toFixed(1)} variant, +1 bulk${starBonus}`;
                }
                if (enchant.value === 2) {
                    const luck = applyStarBonus(10, stars);
                    const speed = applyStarBonus(0.5, stars);
                    const secret = applyStarBonus(25, stars);
                    const variant = applyStarBonus(2.5, stars);
                    return `+${luck.toFixed(1)} luck, +${speed.toFixed(2)}s speed, +${secret.toFixed(1)} secret, +${variant.toFixed(1)} variant, +2 bulk${starBonus}`;
                }
                if (enchant.value === 3) {
                    const luck = applyStarBonus(50, stars);
                    const speed = applyStarBonus(75, stars);
                    const secret = applyStarBonus(125, stars);
                    const variant = applyStarBonus(20, stars);
                    return `+${luck.toFixed(1)} luck, +${speed.toFixed(2)}s speed, +${secret.toFixed(1)} secret, +${variant.toFixed(1)} variant, +5 bulk${starBonus}`;
                }
            }
            if (enchant.type === 'greed') {
                const luck = applyStarBonus(20, stars);
                const speed = applyStarBonus(0.7, stars);
                return `+2 bulk roll, -${luck.toFixed(1)} luck, -${speed.toFixed(2)}s speed${starBonus}`;
            }
            if (enchant.type === 'patience') {
                const luck = applyStarBonus(100, stars);
                const speed = applyStarBonus(25, stars);
                const variant = applyStarBonus(5, stars);
                return `+3 bulk roll, +${luck.toFixed(1)} luck, -${speed.toFixed(2)}s speed, +${variant.toFixed(1)} variant${starBonus}`;
            }
            if (enchant.type === 'alpha') {
                const luck = applyStarBonus(0.25, stars);
                const speed = applyStarBonus(0.05, stars);
                const secret = applyStarBonus(0.5, stars);
                const variant = applyStarBonus(0.125, stars);
                return `+${luck.toFixed(2)} luck, -${speed.toFixed(2)}s speed, +${secret.toFixed(2)} secret, +${variant.toFixed(3)} variant${starBonus}`;
            }
            if (enchant.type === 'delta') {
                const luck = applyStarBonus(2.5, stars);
                const speed = applyStarBonus(0.5, stars);
                const secret = applyStarBonus(5, stars);
                const variant = applyStarBonus(1.25, stars);
                return `+${luck.toFixed(2)} luck, -${speed.toFixed(2)}s speed, +${secret.toFixed(2)} secret, +${variant.toFixed(3)} variant (alpha x10)${starBonus}`;
            }
            if (enchant.type === 'weird') {
                const val = applyStarBonus(enchant.value, stars);
                return `+${val.toFixed(2)} enchant luck${starBonus}`;
            }
            if (enchant.type === 'overtime') {
                const luck = applyStarBonus(enchant.currentLuck, stars);
                const speed = applyStarBonus(enchant.currentSpeed, stars);
                const variant = applyStarBonus(enchant.currentVariant, stars);
                const secret = applyStarBonus(enchant.currentSecret, stars);
                const rolls = (enchant.rollsWithOvertime || 0);
                return `+${luck.toFixed(3)} luck, +${speed.toFixed(3)}s speed, +${variant.toFixed(3)} variant, +${secret.toFixed(3)} secret (${rolls} rolls)${starBonus}`;
            }
            if (enchant.type === 'blessing') {
                return `1/333,333 chance for poly¬≤ (RNG: -2,932,932)${starBonus}`;
            }
            return '';
        }

        function updateCooldownSettings() {
            cooldownThreshold = parseFloat(document.getElementById('cooldownThreshold').value) || 0;
            cooldownTime = parseFloat(document.getElementById('cooldownTime').value) || 3;
            saveGame();
        }

        function getStarDisplay(stars) {
            if (!stars || stars === 0) return '';
            return '‚≠ê'.repeat(stars);
        }

        function updateEnchantInventory() {
            const equippedList = document.getElementById('equippedEnchant');
            const inventoryList = document.getElementById('enchantInventoryList');
            document.getElementById('enchantCount').textContent = formatNumber(enchantOrbs.length);
            document.getElementById('enchants').textContent = formatNumber(enchantOrbs.length);
            
            if (!equippedOrb) {
                equippedList.innerHTML = '<div style="text-align: center; color: #999;">no enchant orb equipped!</div>';
            } else {
                const starDisplay = getStarDisplay(equippedOrb.stars);
                const enchantsList = equippedOrb.enchants.map(e => 
                    `<span style="color: ${e.color}; font-weight: bold;">${e.name}</span>`
                ).join(', ');
                
                const effectsList = equippedOrb.enchants.map(e => getEnchantDescription(e, equippedOrb.stars)).join(' | ');
                
                equippedList.innerHTML = `
                    <div class="inventory-item ${equippedOrb.locked ? 'locked-enchant' : ''}">
                        <div>
                            ${starDisplay ? `<div class="star-display">${starDisplay}</div>` : ''}
                            <div style="margin-bottom: 5px;">${enchantsList}</div>
                            <div style="font-size: 12px; color: #666;">${effectsList}</div>
                            <div style="font-size: 11px; color: #999;">from: ${equippedOrb.sourceRNG ? formatNumber(equippedOrb.sourceRNG) : '?'} ${equippedOrb.variant || ''}</div>
                        </div>
                        <button class="unequip-btn" onclick="unequipEnchantOrb()" style="padding: 5px 15px; font-size: 12px;">unequip</button>
                    </div>
                `;
            }
            
            if (enchantOrbs.length === 0) {
                inventoryList.innerHTML = '<div style="text-align: center; color: #999;">no enchant orbs yet!</div>';
                return;
            }
            
            inventoryList.innerHTML = enchantOrbs.map((orb, index) => {
                const starDisplay = getStarDisplay(orb.stars);
                const enchantsList = orb.enchants.map(e => 
                    `<span style="color: ${e.color}; font-weight: bold;">${e.name}</span>`
                ).join(', ');
                
                const effectsList = orb.enchants.map(e => getEnchantDescription(e, orb.stars)).join(' | ');
                
                const isEquipped = equippedOrb && equippedOrb.id === orb.id;
                
                return `
                    <div class="inventory-item ${orb.locked ? 'locked-enchant' : ''}">
                        <div>
                            ${starDisplay ? `<div class="star-display">${starDisplay}</div>` : ''}
                            <div style="margin-bottom: 5px;">${enchantsList}</div>
                            <div style="font-size: 12px; color: #666;">${effectsList}</div>
                            <div style="font-size: 11px; color: #999;">from: ${orb.sourceRNG ? formatNumber(orb.sourceRNG) : '?'} ${orb.variant || ''}</div>
                        </div>
                        <div>
                            ${isEquipped ? 
                                '<span style="color: #90ee90; font-size: 12px;">equipped</span>' : 
                                `<button class="equip-btn" onclick="equipEnchantOrb(${index})" style="padding: 5px 10px; font-size: 11px;">equip</button>`
                            }
                            <button class="decline-btn" onclick="deleteEnchantOrb(${index})" style="padding: 5px 10px; font-size: 11px;">delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateMergeSelects() {
            const select1 = document.getElementById('mergeOrb1');
            const select2 = document.getElementById('mergeOrb2');
            
            select1.innerHTML = '<option value="-1">Select first orb</option>';
            select2.innerHTML = '<option value="-1">Select second orb</option>';
            
            enchantOrbs.forEach((orb, index) => {
                if (!orb.locked) {
                    const optionText = `Orb ${index + 1}: ${orb.enchants.map(e => e.name).join(', ')} ${orb.stars > 0 ? '‚≠ê'.repeat(orb.stars) : ''}`;
                    select1.innerHTML += `<option value="${index}">${optionText}</option>`;
                    select2.innerHTML += `<option value="${index}">${optionText}</option>`;
                }
            });
            
            updateMergePreview();
        }

        function updateMergePreview() {
            const orb1Index = parseInt(document.getElementById('mergeOrb1').value);
            const orb2Index = parseInt(document.getElementById('mergeOrb2').value);
            const mergeBtn = document.getElementById('mergeBtn');
            const preview = document.getElementById('mergePreview');
            
            if (orb1Index === -1 || orb2Index === -1 || orb1Index === orb2Index) {
                mergeBtn.disabled = true;
                preview.textContent = 'Select two different orbs to merge.';
                return;
            }
            
            const orb1 = enchantOrbs[orb1Index];
            const orb2 = enchantOrbs[orb2Index];
            
            if (orb1.locked || orb2.locked) {
                mergeBtn.disabled = true;
                preview.textContent = 'Cannot merge locked orbs.';
                return;
            }
            
            if (rollCoins < 500) {
                mergeBtn.disabled = true;
                preview.textContent = `Need 500 roll coins to merge (you have ${formatNumber(rollCoins)}).`;
                return;
            }
            
            mergeBtn.disabled = false;
            
            // Check if both orbs have alpha/delta enchants
            const alphaCount1 = orb1.enchants.filter(e => e.name === 'alpha').length;
            const alphaCount2 = orb2.enchants.filter(e => e.name === 'alpha').length;
            const deltaCount1 = orb1.enchants.filter(e => e.name === 'delta').length;
            const deltaCount2 = orb2.enchants.filter(e => e.name === 'delta').length;
            
            // Combine enchants
            const combinedEnchants = [...orb1.enchants, ...orb2.enchants];
            
            // Handle alpha/delta stacking
            const alphaEnchants = combinedEnchants.filter(e => e.name === 'alpha');
            const deltaEnchants = combinedEnchants.filter(e => e.name === 'delta');
            const otherEnchants = combinedEnchants.filter(e => e.name !== 'alpha' && e.name !== 'delta');
            
            // Remove overridden enchants
            const finalEnchants = [];
            const overrideExceptions = ['requiem i', 'requiem ii', 'genesis', 'blitz', 'omnipotence', 'endless', 'unusual', 'unusuality', 'overtime', 'polys blessing'];
            
            if (alphaEnchants.length > 0 || deltaEnchants.length > 0) {
                // Add all alphas and deltas
                finalEnchants.push(...alphaEnchants, ...deltaEnchants);
                
                // Add non-overridden enchants
                otherEnchants.forEach(enchant => {
                    if (!shouldOverrideEnchant(enchant.name) || overrideExceptions.includes(enchant.name.toLowerCase())) {
                        finalEnchants.push(enchant);
                    }
                });
            } else {
                finalEnchants.push(...combinedEnchants);
            }
            
            // Calculate average stars (rounded up)
            const avgStars = Math.ceil((orb1.stars + orb2.stars) / 2);
            
            // Determine if result should be locked (NOT locked if both have alpha or delta)
            const shouldBeLocked = !((alphaCount1 > 0 && alphaCount2 > 0) || (deltaCount1 > 0 && deltaCount2 > 0));
            
            preview.innerHTML = `
                <strong>Merge Preview:</strong><br>
                Combined enchants: ${finalEnchants.map(e => `<span style="color: ${e.color}">${e.name}</span>`).join(', ')}<br>
                Stars: ${avgStars > 0 ? '‚≠ê'.repeat(avgStars) : 'None'}<br>
                Original orbs will be deleted${shouldBeLocked ? ', new orb will be locked.' : '.'}
            `;
        }

        function mergeEnchants() {
            const orb1Index = parseInt(document.getElementById('mergeOrb1').value);
            const orb2Index = parseInt(document.getElementById('mergeOrb2').value);
            
            if (orb1Index === -1 || orb2Index === -1 || orb1Index === orb2Index) return;
            if (rollCoins < 500) return;
            
            const orb1 = enchantOrbs[orb1Index];
            const orb2 = enchantOrbs[orb2Index];
            
            if (orb1.locked || orb2.locked) return;
            
            rollCoins -= 500;
            
            // Check if both orbs have alpha/delta enchants
            const alphaCount1 = orb1.enchants.filter(e => e.name === 'alpha').length;
            const alphaCount2 = orb2.enchants.filter(e => e.name === 'alpha').length;
            const deltaCount1 = orb1.enchants.filter(e => e.name === 'delta').length;
            const deltaCount2 = orb2.enchants.filter(e => e.name === 'delta').length;
            
            // Combine enchants
            const combinedEnchants = [...orb1.enchants, ...orb2.enchants];
            
            // Handle alpha/delta stacking
            const alphaEnchants = combinedEnchants.filter(e => e.name === 'alpha');
            const deltaEnchants = combinedEnchants.filter(e => e.name === 'delta');
            const otherEnchants = combinedEnchants.filter(e => e.name !== 'alpha' && e.name !== 'delta');
            
            // Remove overridden enchants
            const finalEnchants = [];
            const overrideExceptions = ['requiem i', 'requiem ii', 'genesis', 'blitz', 'omnipotence', 'endless', 'unusual', 'unusuality', 'overtime', 'polys blessing'];
            
            if (alphaEnchants.length > 0 || deltaEnchants.length > 0) {
                // Add all alphas and deltas
                finalEnchants.push(...alphaEnchants, ...deltaEnchants);
                
                // Add non-overridden enchants
                otherEnchants.forEach(enchant => {
                    if (!shouldOverrideEnchant(enchant.name) || overrideExceptions.includes(enchant.name.toLowerCase())) {
                        // Special handling for overtime - combine rolls counter
                        if (enchant.type === 'overtime') {
                            const existingOvertime = finalEnchants.find(e => e.type === 'overtime');
                            if (existingOvertime) {
                                // Average the stats
                                existingOvertime.currentLuck = (existingOvertime.currentLuck + enchant.currentLuck) / 2;
                                existingOvertime.currentSpeed = (existingOvertime.currentSpeed + enchant.currentSpeed) / 2;
                                existingOvertime.currentVariant = (existingOvertime.currentVariant + enchant.currentVariant) / 2;
                                existingOvertime.currentSecret = (existingOvertime.currentSecret + enchant.currentSecret) / 2;
                                existingOvertime.rollsWithOvertime = Math.max(existingOvertime.rollsWithOvertime || 0, enchant.rollsWithOvertime || 0);
                            } else {
                                finalEnchants.push(enchant);
                            }
                        } else {
                            finalEnchants.push(enchant);
                        }
                    }
                });
            } else {
                finalEnchants.push(...combinedEnchants);
            }
            
            // Calculate average stars (rounded up)
            const avgStars = Math.ceil((orb1.stars + orb2.stars) / 2);
            
            // Determine if result should be locked (NOT locked if both have alpha or delta)
            const shouldBeLocked = !((alphaCount1 > 0 && alphaCount2 > 0) || (deltaCount1 > 0 && deltaCount2 > 0));
            
            // Create new merged orb
            const mergedOrb = {
                id: Date.now() + Math.random(),
                enchants: finalEnchants,
                sourceRNG: Math.max(orb1.sourceRNG || 0, orb2.sourceRNG || 0),
                variant: orb1.sourceRNG >= orb2.sourceRNG ? orb1.variant : orb2.variant,
                stars: avgStars,
                locked: shouldBeLocked,
                rollsWithOvertime: Math.max(orb1.rollsWithOvertime || 0, orb2.rollsWithOvertime || 0)
            };
            
            // Delete the original orbs
            const higherIndex = Math.max(orb1Index, orb2Index);
            const lowerIndex = Math.min(orb1Index, orb2Index);
            
            enchantOrbs.splice(higherIndex, 1);
            enchantOrbs.splice(lowerIndex, 1);
            
            enchantOrbs.push(mergedOrb);
            
            updateEnchantInventory();
            updateMergeSelects();
            updateUI();
            saveGame();
            
            alert(`Enchants merged successfully! Original orbs deleted${shouldBeLocked ? ', new orb is locked' : ''}.`);
        }

        function updateIndex() {
            // variants index
            const variantsHTML = VARIANTS.map(v => {
                const isDiscovered = discovered.variants.has(v.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                return `<div class="index-item"><span style="${style}">${icon}</span> ${v.name}: ${formatNumber(v.multipliesRNG)}x (1/${formatNumber(v.chance)})</div>`;
            }).join('');
            document.getElementById('variantsIndexItems').innerHTML = variantsHTML;
            
            // normal ranks index
            const normalRanksHTML = RANKS.map(r => {
                const isDiscovered = discovered.ranks.has(r.name) && !SECRETS.some(s => s.name === r.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                const maxDisplay = r.max === Infinity ? '‚àû' : formatNumber(r.max);
                return `<div class="index-item"><span style="${style}">${icon}</span> ${r.name}: ${formatNumber(r.min)} - ${maxDisplay}</div>`;
            }).join('');
            document.getElementById('normalRanksIndexItems').innerHTML = normalRanksHTML;
            
            // secret ranks index
            const secretsHTML = SECRETS.map(s => {
                const isDiscovered = discovered.secrets.has(s.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                let specialNote = '';
                if (s.name === 'solar') specialNote = ' (replaces eclipse, x100,000)';
                if (s.name === 'Completionist') specialNote = ' (requires all normal ranks, always rollable, RNG: -500)';
                if (s.name === 'poly¬≤') specialNote = ' (requires polys blessing, true RNG 1/333,333, RNG: -2,932,932)';
                return `<div class="index-item"><span style="${style}">${icon}</span> ${s.name}: 1/${formatNumber(s.chance)}${specialNote}</div>`;
            }).join('');
            document.getElementById('secretRanksIndexItems').innerHTML = secretsHTML;
            
            // enchants index
            const enchantsHTML = ENCHANT_TYPES.map(enchant => {
                const isDiscovered = discovered.enchants.has(enchant.name);
                const icon = isDiscovered ? '‚úì' : '‚úó';
                const style = isDiscovered ? 'color: #90ee90;' : 'color: #ff6666;';
                let effect = '';
                if (enchant.type === 'luck') effect = `+${enchant.value} luck`;
                if (enchant.type === 'speed') effect = `+${enchant.value}s speed`;
                if (enchant.type === 'secret') effect = `+${enchant.value} secret`;
                if (enchant.type === 'variant') effect = `+${enchant.value} variant luck`;
                if (enchant.type === 'addition') effect = `+${enchant.value} bulk roll`;
                if (enchant.type === 'alpha') effect = `+0.25 luck, -0.05s speed, +0.5 secret, +0.125 variant`;
                if (enchant.type === 'delta') effect = `+2.5 luck, -0.5s speed, +5 secret, +1.25 variant (alpha x10)`;
                if (enchant.type === 'weird') effect = `+${enchant.value} enchant luck`;
                if (enchant.type === 'overtime') effect = `+0.001 luck, +0.001s speed, +0.001 variant, +0.001 secret (grows per roll)`;
                if (enchant.type === 'blessing') effect = `1/333,333 chance for poly¬≤ (RNG: -2,932,932)`;
                if (enchant.type === 'requiem') {
                    if (enchant.value === 1) effect = '+5 luck, +0.25s speed, +5 secret, +0.5 variant, +1 bulk';
                    else if (enchant.value === 2) effect = '+10 luck, +0.5s speed, +25 secret, +2.5 variant, +2 bulk';
                    else if (enchant.value === 3) effect = '+50 luck, +75s speed, +125 secret, +20 variant, +5 bulk';
                }
                if (enchant.type === 'greed') effect = '+2 bulk roll, -20 luck, -0.7s speed';
                if (enchant.type === 'patience') effect = '+3 bulk roll, +100 luck, -25s speed, +5 variant';
                const chanceDisplay = Math.round(1/enchant.chance);
                return `<div class="index-item"><span style="${style}">${icon}</span> ${enchant.name}: ${effect} (1/${formatNumber(chanceDisplay)})</div>`;
            }).join('');
            document.getElementById('enchantsIndexItems').innerHTML = enchantsHTML;
        }

        function calculateInvCost() {
            if (invLevel === 0) return 0;
            return Math.floor(20 * Math.log(invLevel) / Math.log(3));
        }

        function updateUI() {
            document.getElementById('polycoin').textContent = formatNumber(Math.floor(polycoin));
            document.getElementById('best').textContent = formatNumber(bestRoll);
            document.getElementById('rolls').textContent = formatNumber(totalRolls);
            document.getElementById('rollCoins').textContent = formatNumber(rollCoins);
            document.getElementById('tickets').textContent = formatNumber(tickets);
            
            document.getElementById('bulkLevel').textContent = formatNumber(bulkLevel);
            document.getElementById('bulkCost').textContent = formatNumber(bulkCost);
            document.getElementById('bulkBtn').disabled = bulkLevel >= 100 || polycoin < bulkCost;
            
            document.getElementById('luckLevel').textContent = formatNumber(luckLevel);
            document.getElementById('luckAmount').textContent = (luckLevel * 0.5).toFixed(1);
            document.getElementById('luckCost').textContent = formatNumber(luckCost);
            document.getElementById('luckBtn').disabled = luckLevel >= 100 || polycoin < luckCost;
            
            document.getElementById('secretLevel').textContent = formatNumber(secretLevel);
            document.getElementById('secretAmount').textContent = (secretLevel * 0.2).toFixed(1);
            document.getElementById('secretCost').textContent = formatNumber(secretCost);
            document.getElementById('secretBtn').disabled = secretLevel >= 25 || polycoin < secretCost;
            
            const totalSpeedReduction = speedLevel * 0.1 + getTotalEnchantSpeed();
            const minRollSpeed = Math.max(0.05 - (minSpeedUpgrades * 0.01), 0.01);
            document.getElementById('speedLevel').textContent = formatNumber(speedLevel);
            document.getElementById('speedAmount').textContent = Math.max(minRollSpeed, 3 - totalSpeedReduction).toFixed(2);
            document.getElementById('speedCost').textContent = formatNumber(speedCost);
            document.getElementById('speedBtn').disabled = speedLevel >= 25 || polycoin < speedCost;
            
            const nextInvCost = calculateInvCost();
            document.getElementById('invLevel').textContent = formatNumber(10 + invLevel);
            document.getElementById('invCost').textContent = formatNumber(nextInvCost);
            document.getElementById('invBtn').disabled = invLevel >= 40 || polycoin < nextInvCost;
            
            document.getElementById('enchantLuckLevel').textContent = formatNumber(enchantLuckLevel);
            document.getElementById('enchantLuckAmount').textContent = (enchantLuckLevel * 0.05).toFixed(2);
            document.getElementById('enchantLuckCost').textContent = formatNumber(enchantLuckCost);
            document.getElementById('enchantLuckBtn').disabled = enchantLuckLevel >= 15 || polycoin < enchantLuckCost;
            
            document.getElementById('variantLuckLevel').textContent = formatNumber(variantLuckLevel);
            document.getElementById('variantLuckAmount').textContent = (variantLuckLevel * 0.05).toFixed(2);
            document.getElementById('variantLuckCost').textContent = formatNumber(variantLuckCost);
            document.getElementById('variantLuckBtn').disabled = variantLuckLevel >= 30 || polycoin < variantLuckCost;
            
            // Ticket shop updates
            document.getElementById('minSpeedLevel').textContent = formatNumber(minSpeedUpgrades);
            document.getElementById('minSpeedCost').textContent = formatNumber(5);
            document.getElementById('minSpeedBtn').disabled = minSpeedUpgrades >= 4 || tickets < 5;
            
            document.getElementById('ticketProdLevel').textContent = formatNumber(ticketProdLevel);
            document.getElementById('ticketProdCost').textContent = formatNumber(ticketProdCost);
            document.getElementById('ticketProdBtn').disabled = ticketProdLevel >= 2 || tickets < ticketProdCost;
            
            document.getElementById('spinnerStatus').textContent = spinnerUnlocked ? 'unlocked' : 'locked';
            document.getElementById('spinnerCost').textContent = formatNumber(10);
            document.getElementById('spinnerBtn').disabled = spinnerUnlocked || tickets < 10;
            
            document.getElementById('spinBtn').disabled = !spinnerUnlocked || tickets < 5;
        }

        function startTicketTimer() {
            if (ticketInterval) clearInterval(ticketInterval);
            const ticketsPerMinute = 1 + ticketProdLevel;
            ticketInterval = setInterval(() => {
                tickets += ticketsPerMinute;
                updateUI();
                saveGame();
            }, 60000); // 1 minute
        }

        function saveGame() {
            try {
                const saveData = {
                    polycoin,
                    bestRoll,
                    totalRolls,
                    rollCoins,
                    tickets,
                    bulkLevel,
                    bulkCost,
                    luckLevel,
                    luckCost,
                    secretLevel,
                    secretCost,
                    speedLevel,
                    speedCost,
                    invLevel,
                    enchantLuckLevel,
                    enchantLuckCost,
                    variantLuckLevel,
                    variantLuckCost,
                    minSpeedUpgrades,
                    ticketProdLevel,
                    ticketProdCost,
                    spinnerUnlocked,
                    cooldownThreshold,
                    cooldownTime,
                    isAutorolling,
                    discovered: {
                        variants: Array.from(discovered.variants),
                        ranks: Array.from(discovered.ranks),
                        secrets: Array.from(discovered.secrets),
                        enchants: Array.from(discovered.enchants)
                    },
                    inventory: inventory.map(item => ({
                        ...item,
                        enchants: item.enchants ? item.enchants.map(e => {
                            if (e.type === 'overtime') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    baseLuck: e.baseLuck,
                                    baseSpeed: e.baseSpeed,
                                    baseVariant: e.baseVariant,
                                    baseSecret: e.baseSecret,
                                    currentLuck: e.currentLuck,
                                    currentSpeed: e.currentSpeed,
                                    currentVariant: e.currentVariant,
                                    currentSecret: e.currentSecret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            }
                            return {
                                name: e.name,
                                type: e.type,
                                value: e.value,
                                color: e.color,
                                priority: e.priority
                            };
                        }) : []
                    })),
                    enchantOrbs: enchantOrbs.map(orb => ({
                        id: orb.id,
                        enchants: orb.enchants.map(e => {
                            if (e.type === 'overtime') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    baseLuck: e.baseLuck,
                                    baseSpeed: e.baseSpeed,
                                    baseVariant: e.baseVariant,
                                    baseSecret: e.baseSecret,
                                    currentLuck: e.currentLuck,
                                    currentSpeed: e.currentSpeed,
                                    currentVariant: e.currentVariant,
                                    currentSecret: e.currentSecret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            }
                            return {
                                name: e.name,
                                type: e.type,
                                value: e.value,
                                color: e.color,
                                priority: e.priority
                            };
                        }),
                        sourceRNG: orb.sourceRNG,
                        variant: orb.variant,
                        stars: orb.stars || 0,
                        locked: orb.locked || false,
                        rollsWithOvertime: orb.rollsWithOvertime || 0
                    })),
                    equippedOrb: equippedOrb ? {
                        id: equippedOrb.id,
                        enchants: equippedOrb.enchants.map(e => {
                            if (e.type === 'overtime') {
                                return {
                                    name: e.name,
                                    type: e.type,
                                    baseLuck: e.baseLuck,
                                    baseSpeed: e.baseSpeed,
                                    baseVariant: e.baseVariant,
                                    baseSecret: e.baseSecret,
                                    currentLuck: e.currentLuck,
                                    currentSpeed: e.currentSpeed,
                                    currentVariant: e.currentVariant,
                                    currentSecret: e.currentSecret,
                                    color: e.color,
                                    priority: e.priority
                                };
                            }
                            return {
                                name: e.name,
                                type: e.type,
                                value: e.value,
                                color: e.color,
                                priority: e.priority
                            };
                        }),
                        sourceRNG: equippedOrb.sourceRNG,
                        variant: equippedOrb.variant,
                        stars: equippedOrb.stars || 0,
                        locked: equippedOrb.locked || false,
                        rollsWithOvertime: equippedOrb.rollsWithOvertime || 0
                    } : null
                };
                localStorage.setItem('polys-rng-save2', JSON.stringify(saveData));
            } catch (error) {
                console.error('failed to save game:', error);
            }
        }

        function loadGame() {
            try {
                const result = localStorage.getItem('polys-rng-save2');
                if (result) {
                    const saveData = JSON.parse(result);
                    
                    polycoin = saveData.polycoin || 0;
                    bestRoll = saveData.bestRoll || 0;
                    totalRolls = saveData.totalRolls || 0;
                    rollCoins = saveData.rollCoins || 0;
                    tickets = saveData.tickets || 0;
                    bulkLevel = saveData.bulkLevel || 1;
                    bulkCost = saveData.bulkCost || 100;
                    luckLevel = saveData.luckLevel || 0;
                    luckCost = saveData.luckCost || 10;
                    secretLevel = saveData.secretLevel || 0;
                    secretCost = saveData.secretCost || 50;
                    speedLevel = saveData.speedLevel || 0;
                    speedCost = saveData.speedCost || 50;
                    invLevel = saveData.invLevel || 0;
                    enchantLuckLevel = saveData.enchantLuckLevel || 0;
                    enchantLuckCost = saveData.enchantLuckCost || 30;
                    variantLuckLevel = saveData.variantLuckLevel || 0;
                    variantLuckCost = saveData.variantLuckCost || 50;
                    minSpeedUpgrades = saveData.minSpeedUpgrades || 0;
                    ticketProdLevel = saveData.ticketProdLevel || 0;
                    ticketProdCost = saveData.ticketProdCost || 50;
                    spinnerUnlocked = saveData.spinnerUnlocked || false;
                    
                    cooldownThreshold = saveData.cooldownThreshold || 0;
                    cooldownTime = saveData.cooldownTime || 3;
                    document.getElementById('cooldownThreshold').value = cooldownThreshold;
                    document.getElementById('cooldownTime').value = cooldownTime;
                    
                    if (saveData.discovered) {
                        discovered.variants = new Set(saveData.discovered.variants || []);
                        discovered.ranks = new Set(saveData.discovered.ranks || []);
                        discovered.secrets = new Set(saveData.discovered.secrets || []);
                        discovered.enchants = new Set(saveData.discovered.enchants || []);
                    }
                    
                    inventory = saveData.inventory || [];
                    inventory.forEach(item => {
                        if (!item.enchants) item.enchants = [];
                    });
                    
                    enchantOrbs = saveData.enchantOrbs || [];
                    enchantOrbs.forEach(orb => {
                        if (orb.stars === undefined) orb.stars = 0;
                        if (orb.locked === undefined) orb.locked = false;
                        if (orb.rollsWithOvertime === undefined) orb.rollsWithOvertime = 0;
                    });
                    
                    equippedOrb = saveData.equippedOrb || null;
                    if (equippedOrb) {
                        if (equippedOrb.stars === undefined) equippedOrb.stars = 0;
                        if (equippedOrb.locked === undefined) equippedOrb.locked = false;
                        if (equippedOrb.rollsWithOvertime === undefined) equippedOrb.rollsWithOvertime = 0;
                    }
                    
                    // Start ticket timer if game loaded successfully
                    startTicketTimer();
                }
            } catch (error) {
                console.log('no save data found or error loading:', error);
                equippedOrb = null;
                startTicketTimer();
            }
            
            updateRollers();
            updateInventory();
            updateEnchantInventory();
            updateMergeSelects();
            updateIndex();
            updateUI();
            
            if (spinnerUnlocked) {
                document.getElementById('spinnerSection').style.display = 'block';
                createSpinnerWheel();
            }
        }

        // initialize
        updateRollers();
        updateUI();
        updateIndex();
        updateMergeSelects();
        
        // Make inventory and enchant sections open by default
        document.getElementById('inventoryContent').classList.add('open');
        document.getElementById('enchantsContent').classList.add('open');
        
        // Initialize index sections as collapsed
        document.querySelectorAll('.index-items').forEach(el => {
            el.classList.add('collapsed');
        });
        document.querySelectorAll('.index-title').forEach(el => {
            el.classList.add('collapsed');
        });
    </script>
</body>
</html>
